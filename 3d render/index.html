<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Cube Non-Module</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas class="draw"></canvas>

    <!-- Global Three.js (r123) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.123.0/build/three.min.js"></script>
    <!-- Global OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.123.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Global GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.123.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <script>
        const canvas = document.querySelector('.draw');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        let light = new THREE.DirectionalLight(0xffffff, 5);
        light.position.set(0, 1, 1).normalize();
        scene.add(light);

        let ambientLight = new THREE.AmbientLight(0x404040); // soft white light
        
        scene.add(ambientLight);

        let ambientLight2 = new THREE.AmbientLight(0x404040, 0.5); // softer white light
        scene.add(ambientLight2);


        // OrbitControls (global)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Optional: GLTF model

        const loader = new THREE.GLTFLoader();
        let leftEye, rightEye;

        loader.load('skull.glb', function (gltf) {
            const skull = gltf.scene;
            skull.scale.set(10, 10, 10);
            scene.add(skull);

            // Load left eye
            loader.load('human_eye.glb', function (gltfEye) {
                leftEye = gltfEye.scene;
                leftEye.scale.set(0.02, 0.02, 0.02);
                skull.add(leftEye);
                leftEye.position.set(-0.04, 0.11, 0.1);
                leftEye.rotation.set(0, 0, 0);
            });

            // Load right eye
            loader.load('human_eye.glb', function (gltfEye) {
                rightEye = gltfEye.scene;
                rightEye.scale.set(0.02, 0.02, 0.02);
                skull.add(rightEye);
                rightEye.position.set(0.04, 0.11, 0.1);
                rightEye.rotation.set(0, 0, 0);
            });
        });

        

        let mouseX = 0;
        let mouseY = 0;

        window.addEventListener('mousemove', (e) => {
            // normalize mouse from -1 to 1
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;

            // rotate eyes using GSAP
            if (leftEye && rightEye) {
                gsap.to(leftEye.rotation, {
                    x: -mouseY * 0.5,  // up/down rotation
                    y: mouseX * 0.5,   // left/right rotation
                    duration: 0.3,
                    ease: "power2.out"
                });
                gsap.to(rightEye.rotation, {
                    x: -mouseY * 0.5,
                    y: mouseX * 0.5,
                    duration: 0.3,
                    ease: "power2.out"
                });
            }
        });


        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // for OrbitControls autoRotate
            renderer.render(scene, camera);
        }
        animate();


        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>